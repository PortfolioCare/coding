const e='{"documentCount":27,"nextId":27,"documentIds":{"0":"/coding/api-examples.html#runtime-api-examples","1":"/coding/api-examples.html#results","2":"/coding/api-examples.html#theme-data","3":"/coding/api-examples.html#page-data","4":"/coding/api-examples.html#page-frontmatter","5":"/coding/api-examples.html#more","6":"/coding/java/1.html#java虚拟机8-11双版本-jvm高频面试题","7":"/coding/java/1.html#类加载","8":"/coding/java/1.html#_1、类的生命周期","9":"/coding/java/1.html#加载-loading","10":"/coding/java/1.html#连接-linking","11":"/coding/java/1.html#初始化-initialization","12":"/coding/java/1.html#使用-using","13":"/coding/java/1.html#卸载-unloading","14":"/coding/java/1.html#_2、类加载器-jvm类加载机制","15":"/coding/java/1.html#_3、能说一下jvm的内存区域吗","16":"/coding/java/1.html#_4、对象创建的过程了解吗","17":"/coding/java/1.html#_5、对象内存分配方式","18":"/coding/java/1.html#_6、jvm-里-new-对象时-堆会发生抢占吗-jvm是怎么设计来保证线程安全的","19":"/coding/java/1.html#jmap-dump-live-format-b-file-29471-dump-29471","20":"/coding/java/#sd","21":"/coding/java/#hello-vitepress","22":"/coding/markdown-examples.html#markdown-extension-examples","23":"/coding/markdown-examples.html#syntax-highlighting","24":"/coding/markdown-examples.html#custom-containers","25":"/coding/markdown-examples.html#more","26":"/coding/redis/#redis"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[3,1,51],"1":[1,3,1],"2":[2,4,2],"3":[2,4,2],"4":[2,4,2],"5":[1,3,11],"6":[3,1,1],"7":[1,3,9],"8":[2,4,12],"9":[3,6,33],"10":[3,6,39],"11":[3,6,37],"12":[3,6,14],"13":[3,6,15],"14":[3,4,37],"15":[3,4,173],"16":[3,4,35],"17":[2,4,28],"18":[8,4,1243],"19":[6,1,49],"20":[1,1,1],"21":[2,1,2],"22":[3,1,14],"23":[2,3,26],"24":[2,3,21],"25":[1,3,11],"26":[1,1,1]},"averageFieldLength":[2.5555555555555554,3.3703703703703702,69.25925925925925],"storedFields":{"0":{"title":"Runtime API Examples","titles":[]},"1":{"title":"Results","titles":["Runtime API Examples"]},"2":{"title":"Theme Data","titles":["Runtime API Examples","Results"]},"3":{"title":"Page Data","titles":["Runtime API Examples","Results"]},"4":{"title":"Page Frontmatter","titles":["Runtime API Examples","Results"]},"5":{"title":"More","titles":["Runtime API Examples"]},"6":{"title":"java虚拟机8-11双版本-JVM高频面试题","titles":[]},"7":{"title":"类加载","titles":["java虚拟机8-11双版本-JVM高频面试题"]},"8":{"title":"1、类的生命周期","titles":["java虚拟机8-11双版本-JVM高频面试题","类加载"]},"9":{"title":"加载（Loading）","titles":["java虚拟机8-11双版本-JVM高频面试题","类加载","1、类的生命周期"]},"10":{"title":"连接（Linking）","titles":["java虚拟机8-11双版本-JVM高频面试题","类加载","1、类的生命周期"]},"11":{"title":"初始化(Initialization)","titles":["java虚拟机8-11双版本-JVM高频面试题","类加载","1、类的生命周期"]},"12":{"title":"使用（Using）","titles":["java虚拟机8-11双版本-JVM高频面试题","类加载","1、类的生命周期"]},"13":{"title":"卸载（(Unloading）","titles":["java虚拟机8-11双版本-JVM高频面试题","类加载","1、类的生命周期"]},"14":{"title":"2、类加载器， JVM类加载机制","titles":["java虚拟机8-11双版本-JVM高频面试题","类加载"]},"15":{"title":"3、能说一下JVM的内存区域吗？","titles":["java虚拟机8-11双版本-JVM高频面试题","类加载"]},"16":{"title":"4、对象创建的过程了解吗？","titles":["java虚拟机8-11双版本-JVM高频面试题","类加载"]},"17":{"title":"5、对象内存分配方式","titles":["java虚拟机8-11双版本-JVM高频面试题","类加载"]},"18":{"title":"6、JVM 里 new 对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的？","titles":["java虚拟机8-11双版本-JVM高频面试题","类加载"]},"19":{"title":"jmap -dump:live,format=b,file=29471.dump 29471","titles":[]},"20":{"title":"sd","titles":[]},"21":{"title":"Hello VitePress","titles":[]},"22":{"title":"Markdown Extension Examples","titles":[]},"23":{"title":"Syntax Highlighting","titles":["Markdown Extension Examples"]},"24":{"title":"Custom Containers","titles":["Markdown Extension Examples"]},"25":{"title":"More","titles":["Markdown Extension Examples"]},"26":{"title":"redis","titles":[]}},"dirtCount":0,"index":[["```",{"2":{"23":1}}],["文析结果中查找存在大量的对象",{"2":{"19":1}}],["文件分析",{"2":{"19":1}}],["文件较大的话",{"2":{"19":1}}],["文件名",{"2":{"18":1}}],["文件",{"2":{"18":4,"19":2}}],["文件中除了有类的版本",{"2":{"15":1}}],["工具查看",{"2":{"19":1}}],["工具",{"2":{"19":1}}],["装入",{"2":{"19":1}}],["端口是",{"2":{"19":1}}],["浏览器访问",{"2":{"19":1}}],["借助工具分析哪",{"2":{"18":1}}],["及全限定类名",{"2":{"18":1}}],["若达到阀值就会执行",{"2":{"18":1}}],["若一个已经被标记成黑色或者灰色的对象",{"2":{"18":1}}],["摘要信息",{"2":{"18":1}}],["增加很快",{"2":{"18":1}}],["增加引用",{"2":{"18":1}}],["ygc",{"2":{"18":2}}],["yuque",{"2":{"7":1}}],["次数太多",{"2":{"18":1}}],["次数",{"2":{"18":1}}],["次",{"2":{"18":1}}],["输出每个类的对象数量",{"2":{"18":1}}],["输出",{"2":{"18":1}}],["输出的值就是线程栈信息中的",{"2":{"18":1}}],["信息",{"2":{"18":1}}],["秒输出",{"2":{"18":1}}],["0x0000000000000000",{"2":{"18":1}}],["插件",{"2":{"18":1}}],["抓取线程栈",{"2":{"18":1}}],["换行输出",{"2":{"18":1}}],["转换为",{"2":{"18":1}}],["入手",{"2":{"18":1}}],["严重内存泄漏往往伴随频繁的",{"2":{"18":1}}],["错误",{"2":{"18":1}}],["甚至到",{"2":{"18":1}}],["外在病症表现可能有",{"2":{"18":1}}],["弄清楚可疑对象是否满足了进入到老年代的条件才能下结论",{"2":{"18":1}}],["针对大对象或者长生命周期对象导致的fgc",{"2":{"18":1}}],["代码显式调用gc方法比较容易排查",{"2":{"18":1}}],["代码中显式调用了gc方法",{"2":{"18":1}}],["代码中定义的字段内容",{"2":{"18":1}}],["基本上就可以定位到代码层的逻辑了",{"2":{"19":1}}],["基本就能定位到问题在那了使用",{"2":{"18":1}}],["基本类型",{"2":{"10":1}}],["基础组件升级等情况",{"2":{"18":1}}],["排查指南",{"2":{"18":1}}],["公司的监控系统",{"2":{"18":1}}],["公式为",{"2":{"18":1}}],["元空间大小",{"2":{"18":1}}],["包括",{"2":{"18":1}}],["包括jmap",{"2":{"18":1}}],["包括总内存大小",{"2":{"18":1}}],["包括自己的代码甚至框架中的代码",{"2":{"18":1}}],["系统一次性加载了过多数据到内存中",{"2":{"18":1}}],["怎么办",{"2":{"18":1}}],["怎么查默认用的gc是什么呢",{"2":{"18":1}}],["频繁创建了大量对象",{"2":{"18":1}}],["频繁full",{"2":{"18":1}}],["频繁",{"2":{"18":2}}],["|",{"2":{"18":1}}],["时间等信息",{"2":{"18":1}}],["持续飚高说明垃圾回收跟不上对象创建的速度",{"2":{"18":1}}],["持久代等",{"2":{"18":1}}],["打印出进程的所有线程信息",{"2":{"18":1}}],["打印gc回收的过程日志信息",{"2":{"18":1}}],["quot",{"2":{"18":8}}],["queue队列等待finalizer线程执行",{"2":{"18":1}}],["再查对其的引用",{"2":{"19":1}}],["再对步骤1中列出的可能原因做排除法",{"2":{"18":1}}],["再找到创建该对象的业务代码位置",{"2":{"18":1}}],["再打印出对应线程的堆栈信息",{"2":{"18":1}}],["再清理掉整个旧",{"2":{"18":1}}],["列出对应进程里面的线程占用资源情况",{"2":{"18":1}}],["列出系统各个进程的资源占用情况",{"2":{"18":1}}],["问题",{"2":{"18":1}}],["问题分析",{"2":{"18":1}}],["问题解决",{"2":{"18":1}}],["线上服务cpu占用过高怎么排查",{"2":{"18":1}}],["线程栈分析可使用",{"2":{"18":1}}],["线程的信息",{"2":{"18":1}}],["线程的状态",{"2":{"18":1}}],["线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合",{"2":{"18":1}}],["线程",{"2":{"18":1}}],["线程同步本身是一个相对耗时的过程",{"2":{"18":1}}],["线程持有的锁",{"2":{"18":1}}],["保证导出的请求不会一直打到服务端",{"2":{"18":1}}],["保证了对象的实例字段在java代码中可以直接使用",{"2":{"16":1}}],["做防重处理",{"2":{"18":1}}],["知道了问题就容易解决了",{"2":{"18":1}}],["后端代码加分布式锁",{"2":{"18":1}}],["后端也没有做防止重复提交",{"2":{"18":1}}],["后屏幕显示",{"2":{"18":1}}],["于是准备登录后台去测试下",{"2":{"18":1}}],["于是就从线程信息里面找突破点",{"2":{"18":1}}],["首先要从数据库里面查询出来订单信息",{"2":{"18":1}}],["首先我们需要知道三色标记法就是根据可达性分析",{"2":{"18":1}}],["导出堆内存文件快照",{"2":{"18":1}}],["导出订单信息",{"2":{"18":1}}],["导致大对象进入了老年代",{"2":{"18":1}}],["导致这一段时间内这些对象都无法被回收",{"2":{"18":1}}],["导致性能降低",{"2":{"18":1}}],["导致用户程序性能下降",{"2":{"18":1}}],["导致该对象被程序所需要",{"2":{"18":1}}],["导致标记和清除两个过程的执行效率都随对象数量增长而降低",{"2":{"18":1}}],["导致内存泄漏",{"2":{"18":1}}],["导致方法区溢出",{"2":{"15":1}}],["先引发fgc",{"2":{"18":1}}],["先观察垃圾回收的情况",{"2":{"18":1}}],["先找到了几个正在运行的业务线程",{"2":{"18":1}}],["先在本地缓冲区中分配",{"2":{"18":1}}],["获得堆内存的dump文件",{"2":{"18":1}}],["偶发性的引发oom异常",{"2":{"18":1}}],["电商公司的运营后台系统",{"2":{"18":1}}],["电商网站",{"2":{"18":1}}],["面试官非要问怎么办",{"2":{"18":1}}],["好好把烂代码重构一下不比瞎调jvm强",{"2":{"18":1}}],["垃圾回收算法等等",{"2":{"18":1}}],["垃圾回收器依然没有回收完",{"2":{"18":1}}],["垃圾收集",{"2":{"18":1}}],["垃圾收集的压力就降低很多",{"2":{"18":1}}],["垃圾收集器的选择需要权衡的点还是比较多的",{"2":{"18":1}}],["垃圾收集器应该如何选择",{"2":{"18":1}}],["垃圾收集算法主要有三种",{"2":{"18":1}}],["垃圾收集算法了解吗",{"2":{"18":1}}],["跨平台",{"2":{"18":1}}],["火焰图",{"2":{"18":1}}],["开源",{"2":{"18":1}}],["开启远程",{"2":{"18":1}}],["日志分析工具",{"2":{"18":2}}],["请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因",{"2":{"18":1}}],["死循环",{"2":{"18":1}}],["死锁",{"2":{"18":1}}],["生成",{"2":{"18":2}}],["生成线程快照的主要目的是定位线程出现长时间停顿的原因",{"2":{"18":1}}],["生成堆转储快照",{"2":{"18":1}}],["显示在f",{"2":{"18":1}}],["显示堆中对象的统计信息",{"2":{"18":1}}],["显示java堆详细信息",{"2":{"18":1}}],["编译统计",{"2":{"18":1}}],["编译等运行数据",{"2":{"18":1}}],["统计汇总",{"2":{"18":1}}],["统计和原因",{"2":{"18":1}}],["永久区大小",{"2":{"18":1}}],["老区大小",{"2":{"18":1}}],["老区统计",{"2":{"18":1}}],["老年代用的是parallel",{"2":{"18":1}}],["老年代收集器",{"2":{"18":1}}],["老年代使用标记",{"2":{"18":1}}],["老年代",{"2":{"15":1,"18":2}}],["新区大小",{"2":{"18":1}}],["新区统计",{"2":{"18":1}}],["新生代和老年代分别采用了哪些垃圾收集器",{"2":{"18":1}}],["新生代和老年代的大小",{"2":{"18":1}}],["新生代和老年代收集器",{"2":{"18":1}}],["新生代收集器",{"2":{"18":1}}],["新生代垃圾收集主要采用这种算法",{"2":{"18":1}}],["最后引发fgc",{"2":{"18":1}}],["最后导致oom",{"2":{"18":1}}],["最后根据线程的堆栈信息定位到具体业务方法",{"2":{"18":1}}],["最终没有调整任何jvm参数",{"2":{"18":1}}],["最终标记",{"2":{"18":1}}],["最开始也没有认定就是这里的问题",{"2":{"18":1}}],["最大堆大小",{"2":{"18":1}}],["最近一次",{"2":{"18":1}}],["各种报警",{"2":{"18":1}}],["各区大小",{"2":{"18":1}}],["各个线程被调用的方法中使用到的参数",{"2":{"18":1}}],["■",{"2":{"18":22}}],["查询次数",{"2":{"18":1}}],["查看堆的摘要信息",{"2":{"18":1}}],["查看堆内存占用空间最大的前20个对象类型",{"2":{"18":1}}],["查看",{"2":{"18":1}}],["查看进程下的所有线程占",{"2":{"18":1}}],["查看进程使用",{"2":{"18":1}}],["查看运行的",{"2":{"18":1}}],["查看监控",{"2":{"18":1}}],["查看gc次数",{"2":{"18":1}}],["查看是否有线程长时间的watting",{"2":{"18":1}}],["查看是否有引用指向该对象",{"2":{"18":1}}],["查看java进程",{"2":{"18":1}}],["毫秒",{"2":{"18":1}}],["毫秒级别",{"2":{"18":2}}],["间隔时间",{"2":{"18":1}}],["命令分析",{"2":{"19":1}}],["命令并结合dump堆内存文件作进一步分析",{"2":{"18":1}}],["命令选项",{"2":{"18":1}}],["命令行工具的可视化工具",{"2":{"18":1}}],["监控垃圾回收器",{"2":{"18":1}}],["跟踪进去的时候总是卡死",{"2":{"18":1}}],["跟踪内存泄漏",{"2":{"18":1}}],["跟踪各个region回收的",{"2":{"18":1}}],["集成了多个",{"2":{"18":1}}],["集合中我们又可以存放若干其他对象",{"2":{"18":1}}],["集合",{"2":{"18":1}}],["远程开启开关",{"2":{"18":1}}],["备注",{"2":{"18":1}}],["等后端响应之后按钮才可以进行点击",{"2":{"18":1}}],["等",{"2":{"18":1}}],["等等",{"2":{"18":1}}],["性能分析器",{"2":{"18":1}}],["以了解出现问题的时间点以及当前fgc的频率",{"2":{"18":1}}],["以下是一些jdk自带的可视化性能监控和故障处理工具",{"2":{"18":1}}],["以前的收集器分代是划分新生代",{"2":{"18":1}}],["假如逃逸分析能够证明一个对象不会被方法外部访问",{"2":{"18":1}}],["假设现在有白",{"2":{"18":1}}],["标量替换",{"2":{"18":1}}],["标记清除",{"2":{"18":1}}],["标记整理",{"2":{"18":2}}],["标记的范围更小",{"2":{"18":1}}],["标记再并发标记过程中产生的垃圾",{"2":{"18":1}}],["标记了从gc",{"2":{"18":1}}],["标记并发标记阶段产生对象",{"2":{"18":1}}],["标记gc",{"2":{"18":1}}],["标记出所有需要回收的对象",{"2":{"18":1}}],["标记",{"2":{"18":15}}],["同样是输出",{"2":{"18":1}}],["同步消除",{"2":{"18":1}}],["同时维护一个优先级列表",{"2":{"18":1}}],["同时黑色对象引用了该对象",{"2":{"18":1}}],["除此之外",{"2":{"18":2}}],["逃逸分析的好处",{"2":{"18":1}}],["逃逸分析是指分析指针动态范围的方法",{"2":{"18":1}}],["逃逸强度",{"2":{"18":1}}],["逃逸",{"2":{"18":1}}],["通常使用图形化工具分析",{"2":{"19":1}}],["通常会出现",{"2":{"18":1}}],["通常情况下",{"2":{"18":1}}],["通俗点讲",{"2":{"18":1}}],["通过可疑对象定位到具体代码再次分析",{"2":{"18":1}}],["通过线程进行分析",{"2":{"18":1}}],["通过jprofiler查看到占用内存最大的对象是string对象",{"2":{"18":1}}],["通过开启了",{"2":{"18":1}}],["通过监控信息",{"2":{"18":1}}],["通过反射方式执行1里面的三种方式",{"2":{"11":1}}],["通过以下几种方式",{"2":{"11":1}}],["什么是逃逸分析",{"2":{"18":1}}],["什么是三色",{"2":{"18":1}}],["了解jvm的参数设置",{"2":{"18":1}}],["了解该时间点之前有没有程序上线",{"2":{"18":1}}],["了解哪些性jvm监控和故障处理工具",{"2":{"18":1}}],["了",{"2":{"18":1}}],["了一个",{"2":{"18":1}}],["绝对",{"2":{"18":1}}],["随着jit编译期的发展与逃逸分析技术逐渐成熟",{"2":{"18":1}}],["亦或它在没有停顿时间要求的单线程处理器上运行",{"2":{"18":1}}],["大部分公司都会有",{"2":{"18":1}}],["大对象",{"2":{"18":1}}],["大概的一个jvm调优流程图",{"2":{"18":1}}],["大约100",{"2":{"18":1}}],["大规模数据处理",{"2":{"18":1}}],["采用parallel",{"2":{"18":1}}],["采用cas分配重试的方式来保证更新操作的原子性",{"2":{"18":1}}],["还可以说",{"2":{"18":1}}],["还有一些第三方的工具",{"2":{"18":1}}],["还有一项信息是常量池",{"2":{"15":1}}],["还有下面几种方式也比较常用",{"2":{"9":1}}],["出于提高吞吐量的考虑采用parallel",{"2":{"18":1}}],["出来的对象即为根对象",{"2":{"18":1}}],["表示的是新生代用的parallel",{"2":{"18":1}}],["表示当前对象的颜色",{"2":{"18":1}}],["几百g以上用zgc",{"2":{"18":1}}],["几乎",{"2":{"15":1}}],["云服务",{"2":{"18":1}}],["金融交易系统",{"2":{"18":1}}],["服务",{"2":{"18":1,"19":1}}],["服务器所在ip或者域名",{"2":{"18":1}}],["服务器",{"2":{"18":1}}],["企业级应用",{"2":{"18":1}}],["尤其是大堆内存的应用",{"2":{"18":1}}],["停顿时间",{"2":{"18":1}}],["要求尽可能可控",{"2":{"18":1}}],["要分配内存的线程",{"2":{"18":1}}],["默认的呗",{"2":{"18":1}}],["默认的收集器",{"2":{"18":1}}],["默认情况下",{"2":{"18":1}}],["复制",{"2":{"18":1}}],["复制算法解决了标记",{"2":{"18":1}}],["复制算法",{"2":{"18":5}}],["年轻代中eden区与两个survivor区的比值",{"2":{"18":1}}],["年轻代占整个年轻代年老代和的1",{"2":{"18":1}}],["年轻代",{"2":{"18":1}}],["科学计算",{"2":{"18":1}}],["吞吐量优先收集器",{"2":{"18":1}}],["高吞吐",{"2":{"18":1}}],["高吞吐量",{"2":{"18":1}}],["高并发服务器",{"2":{"18":1}}],["示例应用",{"2":{"18":4}}],["应用性能分析工具",{"2":{"18":1}}],["应用程序偶尔会耗尽连接对象",{"2":{"18":1}}],["应用程序抛出",{"2":{"18":1}}],["应用程序长时间连续运行时性能严重下降",{"2":{"18":1}}],["应用程序做性能分析和调优",{"2":{"18":1}}],["应用程序类加载器",{"2":{"14":1}}],["应用响应时间要求高的系统",{"2":{"18":1}}],["应用服务器",{"2":{"18":1}}],["适用于单cpu情况",{"2":{"18":1}}],["适用于需要极低停顿时间",{"2":{"18":2}}],["适用于需要可预测停顿时间的应用",{"2":{"18":1}}],["适用于需要低停顿时间的应用",{"2":{"18":1}}],["适用于多核处理器的高吞吐量应用",{"2":{"18":1}}],["适合类型",{"2":{"18":4}}],["版本之前",{"2":{"18":1}}],["+heapdumponoutofmemoryerror参数",{"2":{"18":1}}],["+printgctimestamps",{"2":{"18":1}}],["+printgcdetails",{"2":{"18":1}}],["+printgc",{"2":{"18":1}}],["+cmsincrementalmode",{"2":{"18":1}}],["+useg1gc",{"2":{"18":1}}],["+useconcmarksweepgc",{"2":{"18":1}}],["+useparalledloldgc",{"2":{"18":1}}],["+useparallelgc",{"2":{"18":1}}],["+useserialgc",{"2":{"18":1}}],["+usetlab",{"2":{"18":1}}],["+",{"2":{"18":5}}],["下图表示垃圾回收器之间有连线表示",{"2":{"18":1}}],["zgc",{"2":{"18":3}}],["zed持有的对象",{"2":{"18":1}}],["你们线上用的什么垃圾收集器",{"2":{"18":1}}],["必须到下一次垃圾收集才能处理",{"2":{"18":1}}],["必须暂停程序",{"2":{"18":1}}],["本来想跟踪着string对象找到其引用的地方",{"2":{"18":1}}],["本次垃圾收集无法处理浮动垃圾",{"2":{"18":1}}],["本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区",{"2":{"15":1}}],["本地方法是使用",{"2":{"15":1}}],["本地方法栈也是线程私有的",{"2":{"15":1}}],["本地方法栈",{"2":{"15":1}}],["本地方法栈和程序计数器是线程隔离的数据区",{"2":{"15":1}}],["用jprofiler",{"2":{"18":1}}],["用户在浏览器中键入",{"2":{"18":1}}],["用户线程依然在运行",{"2":{"18":1}}],["用于垃圾回收器升级",{"2":{"18":1}}],["用于存放编译期生成的各种字面量和符号引用",{"2":{"15":1}}],["缺点",{"2":{"18":1}}],["低停顿",{"2":{"18":1}}],["优化minor",{"2":{"18":1}}],["优点",{"2":{"18":1}}],["优先收集价值高的region",{"2":{"18":1}}],["优先级处理",{"2":{"18":1}}],["把线程id转换为16进制",{"2":{"18":1}}],["把一个java对象拆散",{"2":{"18":1}}],["把回收集中region的存活对象复制到空的region中",{"2":{"18":1}}],["把jar包放到这个ext文件夹下",{"2":{"14":1}}],["构成回收集",{"2":{"18":1}}],["选择多个region",{"2":{"18":1}}],["制定回收计划",{"2":{"18":1}}],["筛选回收",{"2":{"18":1}}],["找到占用内存高的对象",{"2":{"18":1}}],["找到对应线程id后",{"2":{"18":1}}],["找到需要加载的类并把类的信息加载到jvm的方法区中",{"2":{"9":1}}],["找出要回收的对象",{"2":{"18":1}}],["递归扫描整个堆里的对象图",{"2":{"18":1}}],["价值",{"2":{"18":1}}],["更精细的控制",{"2":{"18":1}}],["收集器",{"2":{"18":1}}],["收集器能够对扮演不同角色的region采用不同的策略去处理",{"2":{"18":1}}],["收集器是垃圾收集器的一个颠覆性的产物",{"2":{"18":1}}],["扮演新生代的eden空间",{"2":{"18":1}}],["简称g1",{"2":{"18":1}}],["简单说就是分内存",{"2":{"10":1}}],["简单一句话概括",{"2":{"9":1}}],["清楚排查问题时能使用哪些工具",{"2":{"18":1}}],["清楚从程序角度",{"2":{"18":1}}],["清理掉标记阶段标记的死亡的对象",{"2":{"18":1}}],["清除之后会产生大量不连续的内存碎片",{"2":{"18":1}}],["清除",{"2":{"18":3}}],["清除算法面对大量可回收对象时执行效率低的问题",{"2":{"18":1}}],["清除算法比较基础",{"2":{"18":1}}],["清除算法",{"2":{"18":2}}],["多线程运行",{"2":{"18":1}}],["无停顿",{"2":{"18":2}}],["无法被其他线程访问",{"2":{"18":1}}],["无法被",{"2":{"18":1}}],["无法在任何地方通过反射访问该类的方法",{"2":{"13":1}}],["单方面的加大了堆内存从4g调整到8g",{"2":{"18":1}}],["单核情况下不如serial",{"2":{"18":1}}],["单线程",{"2":{"18":2}}],["单线程运行",{"2":{"18":1}}],["单例对象在初始化后会以静态变量的方式在",{"2":{"18":1}}],["单例模式",{"2":{"18":1}}],["能详细说一下cms收集器的垃圾收集过程吗",{"2":{"18":1}}],["能说一下jvm的内存区域吗",{"0":{"15":1}}],["漏标问题会导致本该存活的对象被回收",{"2":{"18":1}}],["都是通过指针碰撞来分配空间",{"2":{"18":1}}],["都采取了一些措施来应对这些问题",{"2":{"18":1}}],["都支持本地方法",{"2":{"15":1}}],["两种回收器在使用三色标记法时",{"2":{"18":1}}],["此问题会导致系统出现问题",{"2":{"18":1}}],["此内存区域的唯一目的就是存放对象实例",{"2":{"15":1}}],["却又要被gc回收",{"2":{"18":1}}],["删除引用",{"2":{"18":1}}],["留给下一次gc进行处理即可",{"2":{"18":1}}],["重新标记",{"2":{"18":2}}],["重新标记也不会从黑色对象中去找",{"2":{"18":1}}],["重新标记也不能从gc",{"2":{"18":1}}],["重复步骤3",{"2":{"18":1}}],["突然变成了垃圾",{"2":{"18":1}}],["浮动垃圾对系统的影响不大",{"2":{"18":1}}],["浮动垃圾",{"2":{"18":2}}],["传统标记方式发生stop",{"2":{"18":1}}],["仍在",{"2":{"18":1}}],["结果就大量的请求进入到后台",{"2":{"18":1}}],["结果在测试的过程中发现导出订单的按钮前端居然没有做点击后按钮置灰交互事件",{"2":{"18":1}}],["结束后",{"2":{"18":1}}],["结合jvm的内存结构会比较好理解",{"2":{"9":1}}],["直至",{"2":{"18":1}}],["直接用创建若干个成员变量代替",{"2":{"18":1}}],["直接将本地方法栈和虚拟机栈合二为一",{"2":{"15":1}}],["直接从本地内存的堆中分配任意数量的内存",{"2":{"15":1}}],["直接对虚拟机栈的操作只有两个",{"2":{"15":1}}],["直接引用已经在类的初始化中的有过阐述",{"2":{"12":1}}],["直接引用与间接引用等判别条件",{"2":{"12":1}}],["初始堆大小",{"2":{"18":1}}],["初始标记",{"2":{"18":2}}],["初始时",{"2":{"18":1}}],["初始化子类的时候",{"2":{"11":1}}],["初始化三个阶段",{"2":{"9":1}}],["初始化",{"0":{"11":1},"2":{"8":1}}],["黑三个集合",{"2":{"18":1}}],["黑色集合",{"2":{"18":1}}],["黑色",{"2":{"18":1}}],["灰",{"2":{"18":1}}],["灰色集合",{"2":{"18":3}}],["灰色",{"2":{"18":1}}],["且该对象下的属性也全部都被标记过了",{"2":{"18":1}}],["且对象头部分正好是8字节的倍数",{"2":{"18":1}}],["白色集合",{"2":{"18":2}}],["白色",{"2":{"18":1}}],["按",{"2":{"18":1}}],["按照虚拟机规范",{"2":{"15":1}}],["提升标记阶段的效率",{"2":{"18":1}}],["避免重复扫描对象",{"2":{"18":1}}],["移动存活对象是个极为负重的操作",{"2":{"18":1}}],["移动一段与对象大小相等的距离",{"2":{"17":1}}],["算法一样",{"2":{"18":1}}],["算法",{"2":{"18":1}}],["算法分为两个阶段",{"2":{"18":1}}],["整理",{"2":{"18":2}}],["整理算法更加合适",{"2":{"18":1}}],["整理算法主要用于老年代",{"2":{"18":1}}],["整理算法",{"2":{"18":2}}],["实际上",{"2":{"18":1}}],["实际新生代的收集不是按照这个比例",{"2":{"18":1}}],["实例数据区域",{"2":{"18":1}}],["实例数据",{"2":{"18":1}}],["每隔",{"2":{"18":1}}],["每隔一秒打印一次",{"2":{"18":1}}],["每种垃圾回收器之间不是独立操作的",{"2":{"18":1}}],["每一个region都可以根据需要",{"2":{"18":1}}],["每次复制的只是少量的存活对象",{"2":{"18":1}}],["每次只使用其中的一块",{"2":{"18":1}}],["每个",{"2":{"18":1}}],["每个线程在java堆中预先分配一小块内存",{"2":{"18":1}}],["每个方法执行",{"2":{"15":1}}],["过程也比较简单",{"2":{"18":1}}],["执行队列",{"2":{"18":1}}],["执行内存和",{"2":{"18":1}}],["执行",{"2":{"18":1}}],["执行效率不稳定",{"2":{"18":1}}],["执行时加载本地方法库当某个线程调用一个本地方法时",{"2":{"15":1}}],["见名知义",{"2":{"18":1}}],["\\t",{"2":{"18":3}}],["局部变量表",{"2":{"18":1}}],["局部变量等",{"2":{"18":1}}],["○",{"2":{"18":22}}],["属于根对象的还有以下这些",{"2":{"18":1}}],["八是垃圾",{"2":{"18":1}}],["七",{"2":{"18":1}}],["故对象六",{"2":{"18":1}}],["六之间是我们上面所提到的循环引用",{"2":{"18":1}}],["五均是存在根对象的引用",{"2":{"18":1}}],["四",{"2":{"18":1}}],["三色标记查找过程",{"2":{"18":1}}],["三色标记过程",{"2":{"18":1}}],["三色标记算法会产生多标和漏标问题",{"2":{"18":1}}],["三色标记算法是根可达算法的一种实现方案",{"2":{"18":1}}],["三色标记算法",{"2":{"18":1}}],["三色标记算法了解吗",{"2":{"18":1}}],["三",{"2":{"18":1}}],["三个对象各自指向循环中的另一个对象",{"2":{"18":1}}],["二",{"2":{"18":1}}],["反之不存在引用的对象",{"2":{"18":1}}],["反之就是垃圾",{"2":{"18":1}}],["只是做了两个处理",{"2":{"18":1}}],["只是从整体的吞吐量来考量",{"2":{"18":1}}],["只能从堆内存信息下手",{"2":{"18":1}}],["只提供了纯文本控制台环境的服务器上",{"2":{"18":1}}],["只要存在引用指向的对象",{"2":{"18":1}}],["只有连接被关闭后",{"2":{"18":1}}],["只有本地缓冲区用完了",{"2":{"18":1}}],["只有当类被直接引用的时候",{"2":{"11":1}}],["例如接口超时报警等",{"2":{"18":1}}],["例如赋值给可以在其它线程中访问的实例变量",{"2":{"18":1}}],["例如运行应用的基础设施如何",{"2":{"18":1}}],["例如",{"2":{"18":2}}],["根对象不仅仅包括我们上面所说的",{"2":{"18":1}}],["根对象",{"2":{"18":1}}],["根",{"2":{"18":1}}],["根可达算法或根搜索算法",{"2":{"18":2}}],["根据一定的规则实时生成",{"2":{"9":1}}],["存在空间的浪费",{"2":{"18":1}}],["存在的问题",{"2":{"18":2}}],["存储对象类型指针",{"2":{"18":1}}],["存储对象自身的运行时数据",{"2":{"18":1}}],["存储区域",{"2":{"18":3}}],["存储布局",{"2":{"18":1}}],["该对象已经被标记过了",{"2":{"18":2}}],["该对象没有被标记过",{"2":{"18":1}}],["该对象沦为垃圾",{"2":{"18":1}}],["该类对应的java",{"2":{"13":1}}],["该类所有的实例都已经被回收",{"2":{"13":1}}],["没有任何引用再指向该对象",{"2":{"18":1}}],["个对象非常多",{"2":{"18":1}}],["个和",{"2":{"18":1}}],["个引用指向该对象",{"2":{"18":2}}],["部分引用消失",{"2":{"18":1}}],["部分结果",{"2":{"15":1}}],["第四阶段",{"2":{"18":1}}],["第二三阶段",{"2":{"18":1}}],["第一阶段",{"2":{"18":1}}],["有没有处理过内存溢出",{"2":{"18":1}}],["有没有了解逃逸分析技术",{"2":{"18":1}}],["有哪些原因导致fgc",{"2":{"18":1}}],["有个方法引起了我的注意",{"2":{"18":1}}],["有那功夫",{"2":{"18":1}}],["有做过jvm调优吗",{"2":{"18":1}}],["有了cms",{"2":{"18":1}}],["有",{"2":{"18":1}}],["有则说明该对象不是垃圾",{"2":{"18":1}}],["有两个基本的原因归纳如下",{"2":{"14":1}}],["9",{"2":{"18":3}}],["说句题外话",{"2":{"18":1}}],["说明线程在等待这把锁",{"2":{"18":1}}],["说明",{"2":{"18":1}}],["自带的",{"2":{"19":1}}],["自然也无法单独删除了",{"2":{"18":1}}],["自定义加载器",{"2":{"14":1}}],["很可能导致内存泄漏的发生",{"2":{"18":1}}],["很可能存在内存泄漏",{"2":{"18":1}}],["或以使用",{"2":{"19":1}}],["或使用在线分析平台",{"2":{"19":1}}],["或使用第三方式具分析的",{"2":{"19":1}}],["或使用",{"2":{"18":2}}],["或blocked",{"2":{"18":1}}],["或",{"2":{"18":1}}],["或者内存泄露导致对象无法回收",{"2":{"18":1}}],["或者引用",{"2":{"18":1}}],["或者对象",{"2":{"18":1}}],["或者堆空间比较大",{"2":{"18":1}}],["或者垃圾收集暂停必须保持在大约1秒以内",{"2":{"18":1}}],["或者可以接受1秒或更长的停顿时间",{"2":{"18":1}}],["或者一步到位",{"2":{"18":1}}],["或者老年代空间",{"2":{"18":1}}],["或者在创建新的线程时没有足够的内存去创建对应的本地方法栈",{"2":{"15":1}}],["或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈",{"2":{"15":1}}],["或不再使用对象没有及时将对象设置为",{"2":{"18":1}}],["变量不合理的作用域",{"2":{"18":1}}],["变量与方法的合法性",{"2":{"10":1}}],["忘记关闭这些资源会导致持续占有内存",{"2":{"18":1}}],["需要先定位到可疑对象",{"2":{"18":1}}],["需要有严密的分析和监控机制",{"2":{"18":1}}],["需要stw",{"2":{"18":1}}],["需要stop",{"2":{"18":2}}],["需要的对象被回收",{"2":{"18":1}}],["需要注意",{"2":{"18":1}}],["需要注意的是这种划分只是根据垃圾回收机制来进行的划分",{"2":{"15":1}}],["需要调用",{"2":{"18":1}}],["创建的连接不再使用时",{"2":{"18":1}}],["回收所有被标记的对象",{"2":{"18":1}}],["回收",{"2":{"18":2}}],["和",{"2":{"18":3}}],["和用户线程并发执行",{"2":{"18":1}}],["和用户线程同时运行",{"2":{"18":2}}],["和上面的例子原理类似",{"2":{"18":1}}],["和卸载",{"2":{"8":1}}],["一些常见的参数配置",{"2":{"18":1}}],["一般是因为创建了大量对象所导致",{"2":{"18":1}}],["一般来说",{"2":{"18":1}}],["一般称为",{"2":{"18":1}}],["一般的垃圾回收器搭配为",{"2":{"18":1}}],["一边标记垃圾",{"2":{"18":1}}],["一部分空间没有使用",{"2":{"18":1}}],["一堆垃圾",{"2":{"18":1}}],["一致",{"2":{"18":1}}],["一个survivor区占整个年轻代的1",{"2":{"18":1}}],["一个业务线程将一个未被扫描过的白色对象断开引用成为垃圾",{"2":{"18":1}}],["一个变量的定义作用域大于其使用范围",{"2":{"18":1}}],["一个新的对象已经创建完毕",{"2":{"16":1}}],["一个类完整的生命周期",{"2":{"8":1}}],["静态集合的生命周期和",{"2":{"18":1}}],["静态集合类引起内存泄漏",{"2":{"18":1}}],["8000",{"2":{"19":2}}],["8g以上可以用g1",{"2":{"18":1}}],["8g可以用parnew+cms",{"2":{"18":1}}],["8",{"2":{"18":4}}],["8默认使用的是",{"2":{"18":1}}],["就很大概率存在内存泄漏了",{"2":{"18":1}}],["就会导致频繁minor",{"2":{"18":1}}],["就会出现错标和漏标的情况就有可能发生",{"2":{"18":1}}],["就可以访问详情",{"2":{"18":1}}],["就称之为方法逃逸",{"2":{"18":1}}],["就是程序一边运行",{"2":{"18":1}}],["就是根据相应的类自动生成它的代理类",{"2":{"9":1}}],["就将还存活着的对象复制到另外一块上面",{"2":{"18":1}}],["就需要通过对齐填充来补全",{"2":{"18":1}}],["占位符起占位作用",{"2":{"18":1}}],["占位符",{"2":{"18":1}}],["即是",{"2":{"18":1}}],["即对象的大小不是8字节的整数倍",{"2":{"18":1}}],["即对象指向类元数据的指针",{"2":{"18":1}}],["即使仅仅修改一个指针所指向的位置",{"2":{"18":1}}],["偏向时间戳",{"2":{"18":1}}],["偏向线程id",{"2":{"18":1}}],["锁状态标志",{"2":{"18":1}}],["哈希码",{"2":{"18":1}}],["可通过",{"2":{"18":1}}],["可对比正常情况看频率是否正常",{"2":{"18":1}}],["可视化的堆内存分析工具",{"2":{"18":1}}],["可全方位监控jvm的各项指标",{"2":{"18":1}}],["可初步查看是哪个对象占用了内存",{"2":{"18":1}}],["可预测的停顿时间",{"2":{"18":1}}],["可分为三块",{"2":{"18":1}}],["可以使用",{"2":{"19":1}}],["可以使用命令",{"2":{"18":1}}],["可以多抓几次做个对比",{"2":{"18":1}}],["可以从处理问题的角度来回答",{"2":{"18":1}}],["可以很清晰的了解到当前程序是否运行正常",{"2":{"18":1}}],["可以让对象的成员变量在栈上分配和读写",{"2":{"18":1}}],["可以看到有这么一行",{"2":{"18":1}}],["可以协作使用",{"2":{"18":1}}],["可以轻松完成标记",{"2":{"18":1}}],["可以进行回收",{"2":{"18":1}}],["可以作为gc",{"2":{"18":1}}],["可以通过设置",{"2":{"18":1}}],["可以通过参数",{"2":{"15":1}}],["可以选择固定大小也可选择可扩展",{"2":{"15":1}}],["可以划分为以下几个",{"2":{"15":1}}],["小星星",{"2":{"18":65}}],["难度",{"2":{"18":13}}],["薪资范围",{"2":{"18":13}}],["731f",{"2":{"18":2}}],["7000",{"2":{"18":1}}],["7",{"2":{"18":4}}],["设置为增量模式",{"2":{"18":1}}],["设置垃圾回收时间占程序运行时间的百分比",{"2":{"18":1}}],["设置并发收集器年轻代手机方式为并行收集时",{"2":{"18":1}}],["设置并发收集器",{"2":{"18":1}}],["设置并行收集最大的暂停时间",{"2":{"18":1}}],["设置并行收集器收集时使用的cpu数",{"2":{"18":1}}],["设置并行收集器",{"2":{"18":1}}],["设置并行年老代收集器",{"2":{"18":1}}],["设置串行收集器",{"2":{"18":1}}],["设置持久代大小",{"2":{"18":1}}],["设置年轻代和年老代的比值",{"2":{"18":1}}],["设置年轻代大小",{"2":{"18":1}}],["设置",{"2":{"18":1}}],["设置初始值为jvm默认初值",{"2":{"10":1}}],["我们线上采用了设计比较优秀的g1垃圾收集器",{"2":{"18":1}}],["我们比较关注服务的响应速度",{"2":{"18":1}}],["我们顺着根的数据结构往下走",{"2":{"18":1}}],["我们可以回答",{"2":{"18":1}}],["我们可以看到",{"2":{"18":1}}],["我们可以看到一共是存在四个阶段",{"2":{"18":1}}],["我们可以通过",{"2":{"18":1}}],["我们通过下图的引用对象案例来说明",{"2":{"18":1}}],["我们从一个new指令开始",{"2":{"16":1}}],["仅占有整个",{"2":{"18":1}}],["空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作",{"2":{"18":1}}],["空间所占用",{"2":{"18":1}}],["空间的百分比大小",{"2":{"18":1}}],["空间的",{"2":{"18":1}}],["空间的内存非常小",{"2":{"18":1}}],["空闲列表",{"2":{"17":1}}],["参数来关闭tlab功能即可",{"2":{"18":1}}],["方式进行分配",{"2":{"18":1}}],["方式来进行内存分配的",{"2":{"18":1}}],["方法里面的对象",{"2":{"18":1}}],["方法里面我们",{"2":{"18":1}}],["方法里面",{"2":{"18":1}}],["方法来运行",{"2":{"18":1}}],["方法关闭连接",{"2":{"18":1}}],["方法区中常量引用的对象",{"2":{"18":1}}],["方法区中类静态属性引用的对象",{"2":{"18":1}}],["方法区的大小决定了系统可以放多少个类",{"2":{"15":1}}],["方法区的大小和堆空间一样",{"2":{"15":1}}],["方法区",{"2":{"15":2}}],["方法",{"2":{"15":4}}],["方法的调用",{"2":{"15":1}}],["方法执行结束出栈",{"2":{"15":1}}],["●",{"2":{"18":111}}],["解决线程安全问题有两种方案",{"2":{"18":1}}],["解析",{"2":{"10":1}}],["里面",{"2":{"18":1}}],["里的引用",{"2":{"18":1}}],["里",{"0":{"18":1}}],["6",{"0":{"18":1},"2":{"18":3}}],["由于新生代空间较小",{"2":{"18":1}}],["由于不会再对黑色标记过的对象重新扫描",{"2":{"18":1}}],["由于对象修改之后的hah值和存储进容器时的hash值不同",{"2":{"18":1}}],["由于现代垃圾收集器大部分都是基于分代收集理论设计的",{"2":{"15":1}}],["由所采用的垃圾收集器是否带有压缩整理功能决定",{"2":{"17":1}}],["指针会向未使用内存方向移动",{"2":{"17":1}}],["指针碰撞方式",{"2":{"17":1}}],["将线程",{"2":{"18":1}}],["将其用到的成员变量恢复为原始类型来访问",{"2":{"18":1}}],["将本对象挪到",{"2":{"18":1}}],["将本对象引用到的其他对象全部挪到",{"2":{"18":1}}],["将",{"2":{"18":1}}],["将stw变为并发标记",{"2":{"18":1}}],["将可用内存按容量划分为大小相等的两块",{"2":{"18":1}}],["将已使用内存和为使用内存之间放一个分界点的指针",{"2":{"17":1}}],["将class信息加载到jvm的运行时数据区的过程",{"2":{"16":1}}],["取决于",{"2":{"17":1}}],["分析会占比较大的内存",{"2":{"19":1}}],["分析",{"2":{"18":2}}],["分别各有",{"2":{"18":1}}],["分别为",{"2":{"8":1}}],["分配新的缓存区时才需要同步锁定",{"2":{"18":1}}],["分配内存时",{"2":{"17":1}}],["分配过程",{"2":{"17":2}}],["分配方式的选择",{"2":{"17":1}}],["已使用内存和未使用相互交错",{"2":{"17":1}}],["已使用的内存在一边",{"2":{"17":1}}],["未使用内存在另一边",{"2":{"17":1}}],["为了验证自己的猜想",{"2":{"18":1}}],["为了降低内存的消耗",{"2":{"18":1}}],["为3表示年轻代和年老代比值为1",{"2":{"18":1}}],["为什么要用它",{"2":{"18":1}}],["为什么还要引入g1",{"2":{"18":1}}],["为空时结束",{"2":{"18":1}}],["为根对象",{"2":{"18":1}}],["为对象进行必要的设置",{"2":{"16":1}}],["为类的静态变量分配内存",{"2":{"10":1}}],["内存大小",{"2":{"18":1}}],["内存泄漏是内在病源",{"2":{"18":1}}],["内存泄漏",{"2":{"18":2}}],["内存泄漏可能原因",{"2":{"18":1}}],["内存泄漏可能的原因有很多种",{"2":{"18":1}}],["内存泄漏可能由哪些原因导致呢",{"2":{"18":1}}],["内存飚高如果是发生在java进程上",{"2":{"18":1}}],["内存飙高问题怎么排查",{"2":{"18":1}}],["内存",{"2":{"18":2}}],["内存碎片问题",{"2":{"18":1}}],["内存碎片的控制",{"2":{"18":1}}],["内存密集型数据库",{"2":{"18":1}}],["内存占用较大的应用",{"2":{"18":1}}],["内存空间的碎片化问题",{"2":{"18":1}}],["内存空间初始化",{"2":{"16":1}}],["内存中的",{"2":{"18":1}}],["内存分配方式",{"2":{"17":1}}],["内存分配完后",{"2":{"16":1}}],["对应图中事后",{"2":{"18":1}}],["对",{"2":{"18":2}}],["对这个变量实施的同步措施也就可以安全地消除掉",{"2":{"18":1}}],["对齐填充区域",{"2":{"18":1}}],["对齐填充",{"2":{"18":1}}],["对象占用的内存随着栈帧出栈而销毁",{"2":{"18":1}}],["对象漏标问题",{"2":{"18":1}}],["对象间的引用可能发生变化",{"2":{"18":1}}],["对象间的引用是不会发生变化的",{"2":{"18":1}}],["对象垃圾",{"2":{"18":1}}],["对象八不存在引用",{"2":{"18":1}}],["对象五",{"2":{"18":1}}],["对象一定分配在堆中吗",{"2":{"18":2}}],["对象一",{"2":{"18":1}}],["对象hash值改变",{"2":{"18":1}}],["对象头中还有一块记录数组长度的数据",{"2":{"18":1}}],["对象头区域",{"2":{"18":1}}],["对象头",{"2":{"18":1}}],["对象在",{"2":{"18":1}}],["对象时",{"0":{"18":1}}],["对象内存分配方式",{"0":{"17":1}}],["对象创建在虚拟机中是非常频繁的操作",{"2":{"18":1}}],["对象创建才刚开始",{"2":{"16":1}}],["对象创建的过程了解吗",{"0":{"16":1}}],["对象的内存布局",{"2":{"18":1}}],["对象的gc分代年龄等信息",{"2":{"16":1}}],["对象的哈希码",{"2":{"16":1}}],["对象分配内存",{"2":{"16":1}}],["对象所需内存大小在类加载完后可以完全确定",{"2":{"16":1}}],["对于java应用程序来说",{"2":{"15":1}}],["对于非静态的变量",{"2":{"10":1}}],["关注老年代内存使用是否达到阀值",{"2":{"18":1}}],["关注watting",{"2":{"18":1}}],["关闭后方法区即被释放",{"2":{"15":1}}],["关于类的初始化",{"2":{"11":1}}],["受方法区内存的限制",{"2":{"15":1}}],["运行期间也可能将新的常量放入池中",{"2":{"15":1}}],["运行时常量池",{"2":{"15":1}}],["接口等描述信息外",{"2":{"15":1}}],["接口实现类初始化的时候",{"2":{"11":1}}],["字节单位",{"2":{"18":1}}],["字节码",{"2":{"11":1}}],["字符串常量池",{"2":{"18":1}}],["字段",{"2":{"15":1}}],["目的应该是与",{"2":{"15":1}}],["非必须",{"2":{"18":1}}],["非堆",{"2":{"15":1}}],["非静态与非赋值的静态语句均不执行",{"2":{"11":1}}],["但dump文件太大",{"2":{"18":1}}],["但不太讨喜",{"2":{"18":1}}],["但并发并不是非常高",{"2":{"18":1}}],["但其堆内存的布局与其他收集器有非常明显的差异",{"2":{"18":1}}],["但该对象下的属性没有全被标记完",{"2":{"18":1}}],["但后续步骤不是直接对可回收对象进行清理",{"2":{"18":1}}],["但是无法被回收",{"2":{"18":1}}],["但是问题依然没有解决",{"2":{"18":1}}],["但是",{"2":{"18":1}}],["但是主要存在两个缺点",{"2":{"18":1}}],["但是没有其他引用指向这三个对象",{"2":{"18":1}}],["但是它却有一个别名叫",{"2":{"15":1}}],["但从java程序的角度来看",{"2":{"16":1}}],["但对类的初始化时机有",{"2":{"11":1}}],["虽然g1也仍是遵循分代收集理论设计的",{"2":{"18":1}}],["虽然",{"2":{"15":1}}],["堆空间各个区域的大小设置",{"2":{"18":1}}],["堆dump文件进行分析",{"2":{"18":1}}],["堆配置",{"2":{"18":1}}],["堆和永久代的详细信息",{"2":{"18":1}}],["堆状态",{"2":{"18":1}}],["堆会发生抢占吗",{"0":{"18":1}}],["堆内存产生了大量的订单对象和excel对象",{"2":{"18":1}}],["堆内存溢出",{"2":{"18":1}}],["堆内存分析工具",{"2":{"18":1}}],["堆内存绝对规整",{"2":{"17":1}}],["堆内存不规整",{"2":{"17":2}}],["堆内存规整",{"2":{"17":1}}],["堆内存是否规整是由垃圾收集器是否带有压缩整理功能决定的",{"2":{"17":1}}],["堆内存是否规整",{"2":{"17":1}}],["堆内存结构",{"2":{"15":1}}],["堆区分开",{"2":{"15":1}}],["堆一样",{"2":{"15":1}}],["与",{"2":{"15":1}}],["5000",{"2":{"18":2}}],["5",{"0":{"17":1},"2":{"15":1,"18":5}}],["gt",{"2":{"18":1,"19":2}}],["gui图形界面",{"2":{"18":1}}],["g1主要解决了内存碎片过多的问题",{"2":{"18":1}}],["g1收集器运行示意图",{"2":{"18":1}}],["g1收集器的运行过程大致可划分为以下四个步骤",{"2":{"18":1}}],["g1",{"2":{"18":4}}],["g1把连续的java堆划分为多个大小相等的独立区域",{"2":{"18":1}}],["g1垃圾收集器了解吗",{"2":{"18":1}}],["g1则对删除引用环节进行处理",{"2":{"18":1}}],["gif",{"2":{"18":1}}],["gceasy",{"2":{"19":1}}],["gc的排查思路大概如下",{"2":{"18":1}}],["gc的频率",{"2":{"18":1}}],["gc怎么办",{"2":{"18":1}}],["gc频繁问题",{"2":{"18":1}}],["gctimeratio=n",{"2":{"18":1}}],["gc设置",{"2":{"18":1}}],["gcviewer",{"2":{"18":1,"19":1}}],["gchistogc",{"2":{"18":1}}],["gcutil",{"2":{"18":2}}],["gcpermcapacity",{"2":{"18":1}}],["gcoldcapacity",{"2":{"18":1}}],["gcold",{"2":{"18":1}}],["gcnewcapacity",{"2":{"18":1}}],["gcnew",{"2":{"18":1}}],["gccause",{"2":{"18":2}}],["gccapacity",{"2":{"18":1}}],["gc时stop",{"2":{"18":1}}],["gc需要从此对象中去寻找垃圾",{"2":{"18":1}}],["gc",{"2":{"18":23}}],["gc分代年龄",{"2":{"18":1}}],["gc堆",{"2":{"15":1}}],["garbage",{"2":{"15":1,"18":2}}],["因此可以通过增大新生代空间",{"2":{"18":1}}],["因此",{"2":{"18":1}}],["因此一些资料中它也被称作",{"2":{"15":1}}],["因为导出订单数据本来就非常慢",{"2":{"18":1}}],["因为订单信息导出这个方法可能会有几万的数据量",{"2":{"18":1}}],["因为是偶发性的",{"2":{"18":1}}],["因为它不仅满足我们低停顿的要求",{"2":{"18":1}}],["因为我们系统是业务相对复杂",{"2":{"18":1}}],["因为黑色对象的含义为其属性都已经被标记过了",{"2":{"18":1}}],["因为新生代的存活对象比较少",{"2":{"18":1}}],["因为对象的大小必须是8字节的整数倍",{"2":{"18":1}}],["因为对象所需内存的大小在类加载完后可以完全确定",{"2":{"17":1}}],["因为",{"2":{"15":1}}],["所有对象都在",{"2":{"18":1}}],["所有被同步锁synchroni",{"2":{"18":1}}],["所有的对象都分配到堆上也渐渐变得不那么",{"2":{"18":1}}],["所有的对象实例都在这里分配内存",{"2":{"15":1}}],["所有的程序都是从",{"2":{"18":1}}],["所有的字段还是零值",{"2":{"16":1}}],["所谓的",{"2":{"18":1}}],["所以分析排查内存泄漏问题首先还得从查看",{"2":{"18":1}}],["所以先需要找出那个进程占用cpu高",{"2":{"18":1}}],["所以最终导致内存溢出",{"2":{"18":1}}],["所以第一次简单的认为就是堆内存不足导致",{"2":{"18":1}}],["所以采用了cms来降低停顿时间",{"2":{"18":1}}],["所以希望尽可能的利用处理器资源",{"2":{"18":1}}],["所以成为了浮动垃圾",{"2":{"18":1}}],["所以不会被发现",{"2":{"18":1}}],["所以无法找到存入的对象",{"2":{"18":1}}],["所以静态集合引用的对象不能被释放",{"2":{"18":1}}],["所以需要程序员进行初始化操作",{"2":{"16":1}}],["所以java堆中经常会出现新生代",{"2":{"15":1}}],["所以被废弃",{"2":{"14":1}}],["所以类必须完成初始化",{"2":{"9":1}}],["4g以下可以用parallel",{"2":{"18":1}}],["4",{"0":{"16":1},"2":{"15":1,"18":6,"23":1}}],["中大规模",{"2":{"18":1}}],["中引用的对象",{"2":{"18":1}}],["中",{"2":{"15":1,"18":4}}],["中登记",{"2":{"15":1}}],["highlighted",{"2":{"23":2}}],["highlighting",{"0":{"23":1},"2":{"23":2}}],["histo",{"2":{"18":4}}],["hello",{"0":{"21":1}}],["head",{"2":{"18":1}}],["heapdump",{"2":{"18":1}}],["heap",{"2":{"15":3,"18":3,"19":2}}],["hprof",{"2":{"18":1}}],["hp",{"2":{"18":2}}],["http",{"2":{"18":1}}],["https",{"2":{"7":1}}],["home",{"2":{"18":1}}],["hostname=34",{"2":{"18":1}}],["hotspot",{"2":{"15":1,"18":2}}],["hashset等容器中时候",{"2":{"18":1}}],["hash值发生变化",{"2":{"18":1}}],["产品不打算支持",{"2":{"15":1}}],["数据分析",{"2":{"18":1}}],["数据连接",{"2":{"18":1}}],["数据结构等",{"2":{"15":1}}],["数据类型的有效性",{"2":{"10":1}}],["具体实现方式",{"2":{"15":1}}],["具体要看虚拟机的实现方式",{"2":{"9":1}}],["eclipse",{"2":{"19":1}}],["escape",{"2":{"18":1}}],["evacuation",{"2":{"18":1}}],["eden区和s区的大小",{"2":{"18":1}}],["eden区很快被填满",{"2":{"18":1}}],["eden",{"2":{"18":2}}],["eden空间",{"2":{"15":1}}],["engine",{"2":{"15":1}}],["export",{"2":{"23":1}}],["execution",{"2":{"15":1}}],["extensions",{"2":{"18":1,"22":1,"25":1}}],["extension",{"0":{"22":1},"1":{"23":1,"24":1,"25":1},"2":{"14":2}}],["examples",{"0":{"0":1,"22":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1,"23":1,"24":1,"25":1}}],["在线程栈信息中找到对应线程号的",{"2":{"18":1}}],["在线游戏",{"2":{"18":1}}],["在前端的导出订单按钮上加上了置灰状态",{"2":{"18":1}}],["在没有",{"2":{"18":1}}],["在方法中分配后",{"2":{"18":1}}],["在编译期间",{"2":{"18":1}}],["在遍历对象过程中",{"2":{"18":1}}],["在这里插入图片描述",{"2":{"18":2}}],["在并发情况下也会引起线程不安全",{"2":{"18":1}}],["在分配时从列表找一块足够大的空间划分给对象实例",{"2":{"17":1}}],["在java虚拟机",{"2":{"18":1}}],["在jvm中对象的创建",{"2":{"16":1}}],["在jdk8中的这个extension",{"2":{"14":1}}],["在虚拟机启动时创建",{"2":{"15":1}}],["在",{"2":{"15":2,"18":3,"19":1}}],["nid=0x731f",{"2":{"18":1}}],["nid",{"2":{"18":1}}],["n",{"2":{"18":3}}],["null",{"2":{"18":1}}],["newratio=n",{"2":{"18":1}}],["newsize=n",{"2":{"18":1}}],["new+cms的组合",{"2":{"18":1}}],["new",{"0":{"18":1},"2":{"18":3}}],["new关键字创建对象",{"2":{"11":1}}],["non",{"2":{"15":1}}],["native",{"2":{"15":3}}],["语言实现的",{"2":{"15":1}}],["允许线程固定或者可动态扩展的内存大小",{"2":{"15":1}}],["xmn来降低minor",{"2":{"18":1}}],["xms8g",{"2":{"18":1}}],["xms",{"2":{"18":2}}],["x",{"2":{"18":3}}],["xloggc",{"2":{"18":1}}],["xxxxxx",{"2":{"18":1}}],["xxx",{"2":{"18":1}}],["xx",{"2":{"18":22}}],["xss来设置线程的最大栈空间",{"2":{"15":1}}],["x3c",{"2":{"0":8}}],["异常",{"2":{"15":3}}],["那说明是因为对象创建速度快导致内存一直占用很高",{"2":{"18":1}}],["那为什么要用这个呢",{"2":{"18":1}}],["那我们就称",{"2":{"18":1}}],["那现在我们上面所说的引用计数就不能解决这个该问题",{"2":{"18":1}}],["那这三个对象就属于",{"2":{"18":1}}],["那该对象就是垃圾",{"2":{"18":1}}],["那该对象就不是垃圾",{"2":{"18":1}}],["那该对象仍然不是垃圾",{"2":{"18":1}}],["那该对象肯定不是垃圾",{"2":{"18":1}}],["那么很可能是因为内存泄露导致内存一直无法被回收",{"2":{"18":1}}],["那么可以不创建对象",{"2":{"18":1}}],["那么久可以考虑将这个对象在栈上分配",{"2":{"18":1}}],["那么这个变量的读写肯定就不会有竞争",{"2":{"18":1}}],["那么这个对象不是白色的但是不会被清除",{"2":{"18":1}}],["那么这个外部对象将不能被",{"2":{"18":1}}],["那么",{"2":{"15":1}}],["那",{"2":{"15":1}}],["那每个线程的",{"2":{"15":1}}],["那何为衡量类使用完的标准呢",{"2":{"13":1}}],["虚拟机1",{"2":{"18":1}}],["虚拟机内部维护了一个记录可用内存块的列表",{"2":{"17":1}}],["虚拟机为新对象分配内存",{"2":{"17":1}}],["虚拟机为对象进行设置",{"2":{"16":1}}],["虚拟机需要将分配到的内存空间初始化为零值",{"2":{"16":1}}],["虚拟机收到new指令触发",{"2":{"16":1}}],["虚拟机同样会抛出内存溢出错误",{"2":{"15":1}}],["虚拟机规范把方法区描述为堆的一个逻辑部分",{"2":{"15":1}}],["虚拟机规范并没有明确要求本地方法栈的使用语言",{"2":{"15":1}}],["虚拟机规范允许",{"2":{"15":1}}],["虚拟机将会抛出一个outofmemoryerror异常",{"2":{"15":1}}],["虚拟机将会抛出一个",{"2":{"15":2}}],["虚拟机栈用于管理",{"2":{"15":1}}],["虚拟机栈可以动态扩展",{"2":{"15":1}}],["虚拟机栈允许的最大容量",{"2":{"15":1}}],["虚拟机栈容量可以在线程创建的时候独立选定",{"2":{"15":1}}],["虚拟机栈",{"2":{"15":2,"18":1}}],["栈上分配",{"2":{"18":1}}],["栈帧中的本地变量表",{"2":{"18":1}}],["栈的大小直接决定了函数调用的最大可达深度",{"2":{"15":1}}],["栈中可能出现的异常",{"2":{"15":1}}],["栈不存在垃圾回收问题",{"2":{"15":1}}],["栈是一种快速有效的分配存储方式",{"2":{"15":1}}],["压栈",{"2":{"15":1}}],["进制值",{"2":{"18":1}}],["进制",{"2":{"18":1}}],["进程",{"2":{"18":1}}],["进程id",{"2":{"18":1}}],["进栈",{"2":{"15":1}}],["进行类的合法性校验",{"2":{"10":1}}],["伴随着入栈",{"2":{"15":1}}],["访问速度仅次于程序计数器",{"2":{"15":1}}],["特点",{"2":{"15":1}}],["并且这个对象可以被拆散",{"2":{"18":1}}],["并且没有时间要求要求",{"2":{"18":1}}],["并且在尝试扩展的时候无法申请到足够的内存",{"2":{"15":2}}],["并行收集线程数",{"2":{"18":2}}],["并行收集器设置",{"2":{"18":1}}],["并行",{"2":{"18":3}}],["并发",{"2":{"18":1}}],["并发回收时垃圾收集线程可能会抢占用户线程的资源",{"2":{"18":1}}],["并发收集",{"2":{"18":1}}],["并发清除阶段",{"2":{"18":1}}],["并发清除",{"2":{"18":1}}],["并发标记",{"2":{"18":2}}],["并发标记的过程中",{"2":{"18":2}}],["并更新列表上的记录",{"2":{"17":1}}],["并不是所有",{"2":{"15":1}}],["并参与方法的调用和返回",{"2":{"15":1}}],["并设为jvm默认的初值",{"2":{"10":1}}],["程序bug",{"2":{"18":1}}],["程序频繁生成一些长生命周期的对象",{"2":{"18":1}}],["程序所需要的对象",{"2":{"18":1}}],["程序的运行",{"2":{"15":1}}],["程序计数器",{"2":{"15":2}}],["主管",{"2":{"15":1}}],["主要有以下操作步骤",{"2":{"18":1}}],["主要有下面几种情况",{"2":{"12":1}}],["主要是用来排查是否有死锁和某个进程的线程调用栈的情况",{"2":{"18":1}}],["主要用于加载jre环境下的lib下的ext下的jar包",{"2":{"14":1}}],["主要就是加载你自己写的那些类",{"2":{"14":1}}],["作用",{"2":{"15":1}}],["作为程序入口直接运行时",{"2":{"11":1}}],["作为方法区中这个类的信息的入口",{"2":{"9":1}}],["它还可以查询",{"2":{"18":1}}],["它将是运行期定位虚拟机性能问题的首选工具",{"2":{"18":1}}],["它能为您提供强大的分析能力",{"2":{"18":1}}],["它就被称之为标量",{"2":{"18":1}}],["它就进入了一个全新的并且不再受虚拟机限制的世界",{"2":{"15":1}}],["它可以显示本地或者远程虚拟机进程中的类装载",{"2":{"18":1}}],["它可以看作是当前线程所执行的字节码的行号指示器",{"2":{"15":1}}],["它可能被外部所调用",{"2":{"18":1}}],["它同编译器优化原理的指针分析和外形分析相关联",{"2":{"18":1}}],["它开创了局部收集的设计思路和基于region的内存布局形式",{"2":{"18":1}}],["它甚至可以直接使用本地处理器中的寄存器",{"2":{"15":1}}],["它和虚拟机拥有同样的权限",{"2":{"15":1}}],["它的具体做法是",{"2":{"15":1}}],["它的生命周期与线程相同",{"2":{"15":1}}],["它保存方法的局部变量",{"2":{"15":1}}],["也是个图形化工具",{"2":{"19":1}}],["也是线程私有的",{"2":{"15":1}}],["也会停止回收",{"2":{"18":1}}],["也可以无需实现本地方法栈",{"2":{"15":1}}],["也被称为pc寄存器",{"2":{"15":1}}],["也就是本地线程分配缓冲",{"2":{"18":1}}],["也就是java堆中不存在该类的任何实例",{"2":{"13":1}}],["也就是说执行的都是共性的抽象信息",{"2":{"11":1}}],["区域",{"2":{"15":1}}],["区别于对象的初始化",{"2":{"11":1}}],["35k",{"2":{"18":4}}],["30k",{"2":{"18":1}}],["3",{"0":{"15":1},"2":{"15":1,"18":14}}],["扩展能力被取代了又不安全",{"2":{"14":1}}],["扩展类加载器",{"2":{"14":1}}],["总结",{"2":{"18":1}}],["总结下来有如下几种",{"2":{"9":1}}],["总之",{"2":{"14":1}}],["模块化开发",{"2":{"14":1}}],["然而这样的做法并不安全",{"2":{"14":1}}],["然后分析jvm参数设置是否合理",{"2":{"18":1}}],["然后根据锁的地址找到持有锁的线程",{"2":{"18":1}}],["然后根据找到对应进行里哪个线程占用cpu高",{"2":{"18":1}}],["然后就一直点",{"2":{"18":1}}],["然后把订单信息生成excel",{"2":{"18":1}}],["然后逐一跟进业务线程看了下代码",{"2":{"18":1}}],["然后直接清理掉边界以外的内存",{"2":{"18":1}}],["然后再把已使用过的内存空间一次清理掉",{"2":{"18":1}}],["然后从class文件中读取文件内容",{"2":{"9":1}}],["然后在堆区中实例化一个java",{"2":{"9":1}}],["替换了原来的扩展类加载器",{"2":{"14":1}}],["的情况",{"2":{"18":2}}],["的提示后",{"2":{"18":1}}],["的作用并不仅仅是为了获取",{"2":{"18":1}}],["的实时图形化监测工具",{"2":{"18":1}}],["的逃逸",{"2":{"18":1}}],["的大内存应用",{"2":{"18":2}}],["的对象即为gc",{"2":{"18":1}}],["的类型",{"2":{"18":1}}],["的整个生命周期中存在",{"2":{"18":1}}],["的天然的扩展能力所取代",{"2":{"14":1}}],["的原因",{"2":{"14":1}}],["的默认值为0",{"2":{"10":1}}],["负责加载用户自定义路径下的类包",{"2":{"14":1}}],["负责加载classpath路径下的类包",{"2":{"14":1}}],["负责加载支撑jvm运行的位于jre的lib目录下的ext扩展目录中的jar类包",{"2":{"14":1}}],["负责加载支撑jvm运行的位于jre的lib目录下的核心类库",{"2":{"14":1}}],["引入一种针对性的算法",{"2":{"18":1}}],["引用计数",{"2":{"18":2}}],["引用类型的默认值为null",{"2":{"10":1}}],["引导类加载器",{"2":{"14":1}}],["上面的类加载过程主要是通过类加载器来实现的",{"2":{"14":1}}],["当这些对象的存活年龄超过分代年龄时便会进入老年代",{"2":{"18":1}}],["当这一块的内存用完了",{"2":{"18":1}}],["当前用的是哪种收集器等",{"2":{"18":1}}],["当一个对象被new出来之后",{"2":{"18":1}}],["当变量",{"2":{"18":1}}],["当出现循环引用时",{"2":{"18":1}}],["当对象实例数据部分没有对齐时",{"2":{"18":1}}],["当常量池无法再申请到内存时会抛出",{"2":{"15":1}}],["当然面试肯定不能这么答",{"2":{"18":1}}],["当然",{"2":{"15":1,"18":2}}],["当想要扩展java的功能的时候",{"2":{"14":1}}],["当类使用完了之后",{"2":{"13":1}}],["当引用一个类的的常量时",{"2":{"12":1}}],["当引用了一个类的静态变量",{"2":{"12":1}}],["update",{"2":{"18":1}}],["unloading",{"0":{"13":1}}],["useparallelgc",{"2":{"18":1}}],["usetlab",{"2":{"18":1}}],["used",{"2":{"0":1}}],["usedata",{"2":{"0":3}}],["using",{"0":{"12":1}}],["usage",{"2":{"0":1}}],["卸载",{"0":{"13":1}}],["定义一个类的数组",{"2":{"12":1}}],["不增加或增加缓慢",{"2":{"18":1}}],["不是拍脑门就开始调优的",{"2":{"18":1}}],["不是java虚拟机规范本身制定的",{"2":{"15":1}}],["不为ssl连接",{"2":{"18":1}}],["不开启验证",{"2":{"18":1}}],["不可拆分",{"2":{"18":1}}],["不一定的",{"2":{"18":1}}],["不能利用多核",{"2":{"18":1}}],["不提倡使用",{"2":{"14":1}}],["不会引起该类的初始化",{"2":{"12":2}}],["不引起初始化",{"2":{"12":1}}],["不再赘述",{"2":{"12":1}}],["不同的虚拟机对类的加载时机有不同的实现方式",{"2":{"9":1}}],["是如何定位的",{"2":{"18":1}}],["是基于java",{"2":{"18":1}}],["是否检查过",{"2":{"18":1}}],["是方法区的一部分",{"2":{"15":1}}],["是所有线程共享的内存区域",{"2":{"15":1}}],["是虚拟机所管理的内存中最大的一块",{"2":{"15":1}}],["是一款免费的",{"2":{"18":1}}],["是一个内置",{"2":{"18":1}}],["是一个典型的递归模型",{"2":{"11":1}}],["是一块较小的内存空间",{"2":{"15":1}}],["是看对该类的引用是否会引起类的初始化",{"2":{"12":1}}],["如下是",{"2":{"18":1}}],["如下图所示",{"2":{"8":1,"18":1}}],["如3表示eden",{"2":{"18":1}}],["如线程间死锁",{"2":{"18":1}}],["如空间使用率",{"2":{"18":1}}],["如内存泄露",{"2":{"18":1}}],["如上图所示",{"2":{"18":2}}],["如何判断对象仍然存活",{"2":{"18":1}}],["如何找到类的元数据信息",{"2":{"16":1}}],["如设置对象属于哪个类的实例",{"2":{"16":1}}],["如",{"2":{"16":1,"18":4,"19":2}}],["如果发现",{"2":{"18":1}}],["如果会挂掉",{"2":{"18":1}}],["如果每次回收的内存非常少",{"2":{"18":1}}],["如果每次gc次数频繁",{"2":{"18":1}}],["如果线程长期处于watting状态下",{"2":{"18":1}}],["如果线程请求分配的栈容量超过本地方法栈允许的最大容量",{"2":{"15":1}}],["如果线程请求分配的栈容量超过",{"2":{"15":1}}],["如果到这个时间了",{"2":{"18":1}}],["如果一个数据是基本数据类型",{"2":{"18":1}}],["如果逃逸分析能够确定一个变量不会逃逸出线程",{"2":{"18":1}}],["如果确定一个对象不会逃逸到线程之外",{"2":{"18":1}}],["如果对象还有可能被外部线程访问到",{"2":{"18":1}}],["如果是作为参数传递到外部了",{"2":{"18":1}}],["如果是数组",{"2":{"18":1}}],["如果响应时间是高优先级的",{"2":{"18":1}}],["如果响应时间比吞吐量优先级高",{"2":{"18":1}}],["如果优先考虑应用程序的峰值性能",{"2":{"18":1}}],["如果应用程序有一个很小的内存空间",{"2":{"18":1}}],["如果浮动垃圾太多",{"2":{"18":1}}],["如果java堆中包含大量对象",{"2":{"18":1}}],["如果单例对象持有外部的引用",{"2":{"18":1}}],["如果通过tlab分配失败的时候",{"2":{"18":1}}],["如果想要使用cas方式",{"2":{"18":1}}],["如果类没有被类加载器加载",{"2":{"16":1}}],["如果系统类太多",{"2":{"15":1}}],["如果本地方法栈可以动态扩展",{"2":{"15":1}}],["如果",{"2":{"15":2,"19":1}}],["如果采用固定大小的",{"2":{"15":1}}],["如果以上三个条件全部满足",{"2":{"13":1}}],["如果存在父类",{"2":{"11":1}}],["29452",{"2":{"18":2}}],["29471",{"0":{"19":1},"2":{"18":1,"19":1}}],["25",{"2":{"18":1}}],["25k",{"2":{"18":5}}],["24",{"2":{"18":1}}],["23",{"2":{"18":1}}],["22",{"2":{"18":1}}],["20",{"2":{"18":2}}],["20k",{"2":{"18":2}}],["21",{"2":{"18":2}}],["28k",{"2":{"18":1}}],["2",{"0":{"14":1},"2":{"11":1,"15":1,"18":38}}],["记住两句话",{"2":{"11":1}}],["调用main方法",{"2":{"11":1}}],["调用类的静态方法",{"2":{"11":1}}],["读取或设置类的静态变量",{"2":{"11":1}}],["才会回收对应的对象",{"2":{"18":1}}],["才会触发类的初始化",{"2":{"11":1}}],["才真正开始执行类中定义的java程序代码",{"2":{"11":1}}],["之前的动作都由虚拟机主导",{"2":{"11":1}}],["而",{"2":{"18":1}}],["而string对象占用比较多也比较正常",{"2":{"18":1}}],["而是按照若干个region集进行收集",{"2":{"18":1}}],["而是让所有存活的对象都向内存空间一端移动",{"2":{"18":1}}],["而cms与g1",{"2":{"18":1}}],["而并发标记在标记期间应用线程还在继续跑",{"2":{"18":1}}],["而使用并发标记",{"2":{"18":1}}],["而且每次回收的内存空间也正常",{"2":{"18":1}}],["而且方法执行非常慢",{"2":{"18":1}}],["而且解决了cms的浮动垃圾问题",{"2":{"18":1}}],["而且这种操作需要stop",{"2":{"18":1}}],["而且其中大部分是需要被回收的",{"2":{"18":1}}],["而因hotspot",{"2":{"18":1}}],["而本地方法栈用于管理本地方法的调用",{"2":{"15":1}}],["而该静态变量继承自父类的话",{"2":{"12":1}}],["而类的间接引用",{"2":{"12":1}}],["而我们知道",{"2":{"11":1}}],["而也是到了该阶段",{"2":{"11":1}}],["而不是程序设定",{"2":{"10":1}}],["这是一个示例文档",{"2":{"21":1}}],["这是一个中规中矩的案例",{"2":{"18":1}}],["这些功能包括生成和分析海量数据",{"2":{"18":1}}],["这些信息存放在对象头中",{"2":{"16":1}}],["这样双管齐下",{"2":{"18":1}}],["这样一来",{"2":{"18":1}}],["这样一个真正可用的对象才算完全产生出来",{"2":{"16":1}}],["这样就会被其他方法或者线程所引用",{"2":{"18":1}}],["这样就避免了收集整个堆",{"2":{"18":1}}],["这两部可以不分先后顺序",{"2":{"18":1}}],["这个工具利用了内建到jvm里面的jmx指令来对java进程提供实时的性能和资源的监控",{"2":{"18":1}}],["这个过程会产生大量的string对象",{"2":{"18":1}}],["这个过程就称为标量替换",{"2":{"18":1}}],["这个过程大概图示如下",{"2":{"16":1}}],["这个默认虽然也有说法",{"2":{"18":1}}],["这个条件将对象标记成三种颜色",{"2":{"18":1}}],["这时候要结合gc原理和jvm参数设置",{"2":{"18":1}}],["这时必须进行大量标记和清除的动作",{"2":{"18":1}}],["这时我们就需要使用另外一种定位方式",{"2":{"18":1}}],["这时垃圾回收器就可以将其回收",{"2":{"18":1}}],["这也是为什么string类型被设置成了不可变类型",{"2":{"18":1}}],["这也会造成内存泄漏",{"2":{"18":1}}],["这种就被称为线程逃逸",{"2":{"18":1}}],["这种现象称作指针",{"2":{"18":1}}],["这种算法存在一个明显的缺点",{"2":{"18":1}}],["这种特性被开发人员利用得比较多的是",{"2":{"15":1}}],["这种扩展机制被jdk9开始加入的",{"2":{"14":1}}],["这部分内容将类在加载后进入方法区的运行时常量池中存放",{"2":{"15":1}}],["这一阶段的任务就是把常量池中的符号引用转换为直接引用",{"2":{"10":1}}],["这里简单地列一下上面提到的一些收集器的适用场景",{"2":{"18":1}}],["这里不做展开",{"2":{"9":1}}],["这里要区别一下接触到的类加载",{"2":{"9":1}}],["则会回到eden区通过",{"2":{"18":1}}],["则执行类加载流程",{"2":{"16":1}}],["则父类先进行初始化",{"2":{"11":1}}],["则准备阶段中a的初值就是100",{"2":{"10":1}}],["则不会为它们分配内存",{"2":{"10":1}}],["常见的垃圾回收器",{"2":{"18":1}}],["常量的默认值为我们程序中设定的值",{"2":{"10":1}}],["常用参数",{"2":{"18":1}}],["常用形式",{"2":{"18":1}}],["常用",{"2":{"9":2}}],["规则如下",{"2":{"10":1}}],["注意survivor区有两个",{"2":{"18":1}}],["注意",{"2":{"10":1,"19":1}}],["赋初值",{"2":{"10":1}}],["准备",{"2":{"10":1}}],["准备和解析三个步骤",{"2":{"8":1}}],["确保被加载的类能够正常被jvm运行",{"2":{"10":1}}],["继承与实现的规范性等等进行检查",{"2":{"10":1}}],["会产生所谓的理",{"2":{"18":1}}],["会自上而下运行静态代码块或静态赋值语句",{"2":{"11":1}}],["会触发新的垃圾回收",{"2":{"18":1}}],["会触发直接或间接实现的所有接口的初始化",{"2":{"11":1}}],["会触发父类的初始化",{"2":{"11":1}}],["会对比如字节码格式",{"2":{"10":1}}],["会经历五个阶段",{"2":{"8":1}}],["验证",{"2":{"10":1}}],["其监控内容包括",{"2":{"18":1}}],["其指针有可能被返回或者被全局引用",{"2":{"18":1}}],["其实",{"2":{"18":1}}],["其实这与直接从class文件中获取的方式本质",{"2":{"9":1}}],["其目的是为了找出所有可达对象",{"2":{"18":1}}],["其遍历访问过程为",{"2":{"18":1}}],["其中元空间被打满",{"2":{"18":1}}],["其中一种重要的技术叫做逃逸分析",{"2":{"18":1}}],["其中有一部分优化的目的就是减少内存堆分配压力",{"2":{"18":1}}],["其中漏标问题最严重",{"2":{"18":1}}],["其中的标记过程仍然与",{"2":{"18":1}}],["其中的连接又分为验证",{"2":{"8":1}}],["其中方法区和堆是线程共享区",{"2":{"15":1}}],["比如io对象使用完后未调用close方法释放资源",{"2":{"18":1}}],["比如sql查询未做分页",{"2":{"18":1}}],["比如",{"2":{"18":3}}],["比如rt",{"2":{"14":1}}],["比如我们在程序中定义final",{"2":{"10":1}}],["比如设计模式中的动态代理模式",{"2":{"9":1}}],["比如10年前十分流行的applet",{"2":{"9":1}}],["从菜单",{"2":{"19":1}}],["从代码和业务场景中定位具体问题",{"2":{"18":1}}],["从代码逻辑中找到问题所在",{"2":{"18":1}}],["从打印出来的线程信息中找到上一步转换为16进制的线程id对应的线程信息",{"2":{"18":1}}],["从而导致严重的程序问题",{"2":{"18":1}}],["从灰色集合中获取对象",{"2":{"18":1}}],["从gc",{"2":{"18":3}}],["从堆中划出一块确定大小的内存",{"2":{"17":1}}],["从堆中划分出一块确定大小的内存",{"2":{"16":1}}],["从虚拟机的角度来看",{"2":{"16":1}}],["从回收内存的角度看",{"2":{"15":1}}],["从非class文件中获取",{"2":{"9":1}}],["从网络中获取",{"2":{"9":1}}],["从jar文件中读取",{"2":{"9":1}}],["另外",{"2":{"9":1}}],["据类的全路径名找到相应的class文件",{"2":{"9":1}}],["localhost",{"2":{"18":1}}],["local",{"2":{"18":1}}],["long",{"2":{"10":1}}],["loading",{"0":{"9":1}}],["line",{"2":{"23":1}}],["linking",{"0":{"10":1}}],["like",{"2":{"23":1}}],["live",{"0":{"19":1},"2":{"18":3}}],["list",{"2":{"5":1,"18":3,"25":1}}],["lang",{"2":{"9":1,"13":1,"18":1}}],["使用jstat",{"2":{"18":1}}],["使用jdk的发行商是什么",{"2":{"18":1}}],["使用top",{"2":{"18":1}}],["使用率飙升",{"2":{"18":1}}],["使用visualvm对dump文件进行离线分析",{"2":{"18":1}}],["使用的人员可能发现点击后很久后页面都没反应",{"2":{"18":1}}],["使用的cpu数",{"2":{"18":1}}],["使用完threadlocal一定要记得使用remove方法来进行清除",{"2":{"18":1}}],["使用hashmap",{"2":{"18":1}}],["使用平台类加载器",{"2":{"14":1}}],["使用",{"0":{"12":1},"2":{"8":1,"18":3}}],["连接",{"0":{"10":1},"2":{"8":1,"9":1}}],["加载该类的classloader已经被回收",{"2":{"13":1}}],["加载",{"0":{"9":1},"2":{"8":1}}],["类",{"2":{"18":1}}],["类就要进入卸载阶段了",{"2":{"13":1}}],["类就是对象实例的抽象",{"2":{"11":1}}],["类被直接引用的情况有以下几种",{"2":{"11":1}}],["类初始化阶段是类加载过程的最后一步",{"2":{"11":1}}],["类的使用",{"2":{"18":1}}],["类的使用分为直接引用和间接引用",{"2":{"12":1}}],["类的卸载过程其实就是在方法区中清空类信息",{"2":{"13":1}}],["类的初始化所做的一起都是基于类变量或类语句的",{"2":{"11":1}}],["类的初始化",{"2":{"11":1}}],["类的加载方式比较灵活",{"2":{"9":1}}],["类的加载阶段就是",{"2":{"9":1}}],["类的生命周期",{"0":{"8":1},"1":{"9":1,"10":1,"11":1,"12":1,"13":1}}],["类加载异常等",{"2":{"18":1}}],["类加载检查",{"2":{"16":1}}],["类加载器",{"0":{"14":1},"2":{"18":1}}],["类加载强调一个jvm能够直接使用所需的类",{"2":{"9":1}}],["类加载其实包括加载",{"2":{"9":1}}],["类加载",{"0":{"7":1},"1":{"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1,"18":1}}],["1+n",{"2":{"18":1}}],["19",{"2":{"18":1}}],["18",{"2":{"18":1}}],["17",{"2":{"18":1}}],["16",{"2":{"18":3}}],["15",{"2":{"18":2}}],["141",{"2":{"18":1}}],["14",{"2":{"18":1}}],["13616",{"2":{"18":1}}],["13",{"2":{"18":1}}],["11",{"2":{"18":1}}],["11双版本",{"0":{"6":1},"1":{"7":1,"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1,"18":1}}],["126",{"2":{"18":1}}],["12",{"2":{"18":5}}],["10",{"2":{"18":9}}],["1000",{"2":{"18":1}}],["100",{"2":{"10":1,"18":2}}],["1",{"0":{"8":1},"1":{"9":1,"10":1,"11":1,"12":1,"13":1},"2":{"11":1,"15":1,"18":17}}],["warning",{"2":{"24":6}}],["with",{"2":{"23":1}}],["web",{"2":{"18":2}}],["world",{"2":{"18":4}}],["world时",{"2":{"18":1}}],["world才能进行",{"2":{"18":1}}],["works",{"2":{"0":1}}],["www",{"2":{"7":1}}],["jsexport",{"2":{"23":1}}],["jstack用于生成虚拟机当前时刻的线程快照",{"2":{"18":1}}],["jstack",{"2":{"18":5}}],["jstat等常用命令",{"2":{"18":1}}],["jstat是用于监视虚拟机各种运行状态信息的命令行工具",{"2":{"18":1}}],["jstat",{"2":{"18":5}}],["jprofiler",{"2":{"19":1}}],["jprofiler商用的性能分析利器",{"2":{"18":1}}],["jps",{"2":{"18":2}}],["jhat",{"2":{"18":2,"19":3}}],["jit",{"2":{"18":2}}],["jit会对代码做很多优化",{"2":{"18":1}}],["jmap用于生成堆转储快照",{"2":{"18":1}}],["jmap",{"0":{"19":1},"2":{"18":8}}],["jmc主要界面",{"2":{"18":1}}],["jmx远程调用端口",{"2":{"18":1}}],["jmxremote",{"2":{"18":4}}],["jmx",{"2":{"18":1}}],["jvisualvm",{"2":{"18":2,"19":1}}],["jvm参数设置问题",{"2":{"18":1}}],["jvm调优是不得已而为之",{"2":{"18":1}}],["jvm调优是一件很严肃的事情",{"2":{"18":1}}],["jvm调优大致流程图",{"2":{"18":1}}],["jvm的常见参数配置知道哪些",{"2":{"18":1}}],["jvm可以确定这个对象属于哪个类的实例",{"2":{"18":1}}],["jvm是怎么设计来保证线程安全的",{"0":{"18":1}}],["jvm",{"0":{"18":1},"2":{"15":5,"18":2}}],["jvm内存分为线程私有区和线程共享区",{"2":{"15":1}}],["jvm内存区域最粗略的划分可以分为堆和栈",{"2":{"15":1}}],["jvm类加载机制",{"0":{"14":1}}],["jvm就会在方法区垃圾回收的时候对类进行卸载",{"2":{"13":1}}],["jvm对类的加载时机没有明确规范",{"2":{"11":1}}],["jvm高频面试题",{"0":{"6":1},"1":{"7":1,"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1,"18":1}}],["jconsole概览",{"2":{"18":1}}],["jconsole管理内存相当于可视化的jstat命令",{"2":{"18":1}}],["jconsole",{"2":{"18":2}}],["jdk的自带工具",{"2":{"18":1}}],["jdk8",{"2":{"18":1}}],["jdk8以后",{"2":{"14":1}}],["jdk8以后废弃扩展类加载器",{"2":{"14":1}}],["jdk",{"2":{"18":3,"19":1}}],["jar等",{"2":{"14":1}}],["jar",{"2":{"14":1,"18":2}}],["java进程的内存使用",{"2":{"18":1}}],["java类的引用类型静态变量",{"2":{"18":1}}],["java类的整个生命周期就结束了",{"2":{"13":1}}],["java里",{"2":{"15":1}}],["java里有如下几种类加载器",{"2":{"14":1}}],["java堆内存的永久保存区域的类加载器的统计信息",{"2":{"18":1}}],["java堆内存是否规整",{"2":{"17":1}}],["java堆是否规整",{"2":{"17":1}}],["java堆是垃圾收集器管理的内存区域",{"2":{"15":1}}],["java堆是被所有线程共享的一块内存区域",{"2":{"15":1}}],["java堆",{"2":{"15":2}}],["java",{"2":{"15":18,"18":7}}],["java虚拟机将会抛出一个outofmemoryerror异常",{"2":{"15":1}}],["java虚拟机栈的大小是动态的或者是固定不变的",{"2":{"15":1}}],["java虚拟机栈",{"2":{"15":2}}],["java虚拟机运行时数据区",{"2":{"15":1}}],["java虚拟机8",{"0":{"6":1},"1":{"7":1,"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1,"18":1}}],["os",{"2":{"18":1}}],["oom",{"2":{"18":1}}],["on",{"2":{"18":1}}],["old的组合",{"2":{"18":1}}],["old",{"2":{"18":6}}],["output",{"2":{"23":1,"24":1}}],["outofmemoryerror",{"2":{"15":1,"18":1}}],["out",{"2":{"5":1,"25":1}}],["of",{"2":{"0":2,"5":1,"22":1,"25":1}}],["runnable",{"2":{"18":2}}],["runtime",{"0":{"0":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1},"2":{"0":1,"5":1,"15":1}}],["rmi",{"2":{"18":1}}],["root开始对堆中对象进行可达性分析",{"2":{"18":1}}],["root开始直接关联可达的对象",{"2":{"18":1}}],["root中去找到",{"2":{"18":1}}],["roots直达对象开始遍历整个对象图",{"2":{"18":1}}],["roots直接引用到的对象挪到",{"2":{"18":1}}],["roots能直达的对象",{"2":{"18":1}}],["roots不可达",{"2":{"18":1}}],["roots开始进行遍历访问",{"2":{"18":1}}],["roots的主要有四种对象",{"2":{"18":1}}],["root",{"2":{"18":3,"19":1}}],["redis",{"0":{"26":1}}],["return",{"2":{"23":2}}],["ready",{"2":{"18":1}}],["region的全部空间",{"2":{"18":1}}],["regions",{"2":{"18":1}}],["region",{"2":{"18":2}}],["register",{"2":{"15":1}}],["remark",{"2":{"18":2}}],["reference",{"2":{"18":2}}],["resultset",{"2":{"18":1}}],["results",{"0":{"1":1},"1":{"2":1,"3":1,"4":1},"2":{"0":1}}],["=",{"2":{"0":1,"10":1,"18":2}}],["features",{"2":{"23":1}}],["file",{"2":{"19":1}}],["file=29471",{"0":{"19":1}}],["file=",{"2":{"18":1}}],["filename",{"2":{"18":1}}],["files",{"2":{"0":1}}],["finalizer方法的对象",{"2":{"18":1}}],["finalizerinfo",{"2":{"18":1}}],["finalize",{"2":{"18":1}}],["first",{"2":{"18":1}}],["floating",{"2":{"18":1}}],["float",{"2":{"10":1}}],["full",{"2":{"5":1,"18":8,"25":1}}],["frontmatter",{"0":{"4":1},"2":{"0":3,"4":1}}],["from",{"2":{"0":1,"15":1}}],["format=b",{"0":{"19":1},"2":{"18":1}}],["for",{"2":{"0":1,"5":1,"25":1}}],["vmid",{"2":{"18":2}}],["vm的要求对象起始地址必须是8字节的整数倍",{"2":{"18":1}}],["visualvm",{"2":{"18":3}}],["virtual",{"2":{"15":1}}],["vitepress",{"0":{"21":1},"2":{"0":2,"22":1,"23":1}}],["vue",{"2":{"0":1}}],["msg",{"2":{"23":2}}],["mem",{"2":{"18":2}}],["method",{"2":{"15":2}}],["minor",{"2":{"18":1}}],["myheapdump",{"2":{"18":1}}],["mb",{"2":{"18":1}}],["mat",{"2":{"19":1}}],["mat等",{"2":{"18":1}}],["matjava",{"2":{"18":1}}],["maxgcpausemillis=n",{"2":{"18":1}}],["maxpermsize=n",{"2":{"18":1}}],["management",{"2":{"18":5}}],["markdown",{"0":{"22":1},"1":{"23":1,"24":1,"25":1},"2":{"22":1,"25":1}}],["marking",{"2":{"18":1}}],["mark",{"2":{"18":8}}],["machine",{"2":{"15":1}}],["main",{"2":{"0":1,"18":4}}],["more",{"0":{"5":1,"25":1}}],["md```js",{"2":{"23":1}}],["md",{"2":{"0":2,"24":1}}],["id",{"2":{"18":2}}],["is",{"2":{"18":1,"24":10}}],["io",{"2":{"18":1}}],["image",{"2":{"18":20}}],["import",{"2":{"0":1}}],["info",{"2":{"24":4}}],["input",{"2":{"23":1,"24":1}}],["increment",{"2":{"18":1}}],["initial",{"2":{"18":2}}],["initialization",{"0":{"11":1}}],["init是对对象级别的变量或非静态代码块进行初始化的",{"2":{"16":1}}],["int值为0",{"2":{"16":1}}],["intern",{"2":{"15":1}}],["int",{"2":{"10":2}}],["in",{"2":{"0":1,"22":1}}],["it",{"2":{"0":1}}],["custom",{"0":{"24":1}}],["current",{"2":{"0":1}}],["created",{"2":{"19":1}}],["cpu飙高",{"2":{"18":1}}],["cpu高一定是某个程序长期占用了cpu资源",{"2":{"18":1}}],["cpu",{"2":{"18":4}}],["cpu使用",{"2":{"18":1}}],["cms的并发能力比较依赖于cpu资源",{"2":{"18":1}}],["cms同样有三个明显的缺点",{"2":{"18":1}}],["cms最主要的优点在名字上已经体现出来",{"2":{"18":1}}],["cms",{"2":{"18":7}}],["cms收集齐的垃圾收集分为四步",{"2":{"18":1}}],["cms对增加引用环节进行处理",{"2":{"18":1}}],["cas",{"2":{"18":1}}],["can",{"2":{"0":1}}],["close",{"2":{"18":1}}],["clipboard",{"2":{"18":1}}],["clinit静态变量或者静态代码块谁来初始化呢",{"2":{"16":1}}],["class",{"2":{"15":1,"18":1}}],["classloader",{"2":{"14":4}}],["class对象没有任何地方被引用",{"2":{"13":1}}],["class对象",{"2":{"9":1}}],["c",{"2":{"15":1}}],["charsets",{"2":{"14":1}}],["char",{"2":{"10":1}}],["check",{"2":{"5":1,"25":1}}],["counting",{"2":{"18":1}}],["count",{"2":{"18":2}}],["counter",{"2":{"15":1}}],["containers",{"0":{"24":1}}],["concurrent",{"2":{"18":5}}],["connection",{"2":{"18":1}}],["constant",{"2":{"15":2}}],["const",{"2":{"0":1}}],["collected",{"2":{"15":1}}],["compiler",{"2":{"18":1}}],["compact",{"2":{"18":1}}],["com",{"2":{"7":1}}],["details",{"2":{"24":4}}],["default",{"2":{"23":2}}],["demonstrates",{"2":{"0":1,"22":1}}],["dangerous",{"2":{"24":2}}],["danger",{"2":{"24":2}}],["daemon",{"2":{"18":1}}],["data",{"0":{"2":1,"3":1},"2":{"0":3,"18":1,"23":2}}],["dumping",{"2":{"19":1}}],["dump堆内存信息到文件",{"2":{"18":1}}],["dump",{"0":{"19":2},"2":{"18":7,"19":7}}],["djava",{"2":{"18":1}}],["dcom",{"2":{"18":4}}],["doescapeanalysis",{"2":{"18":1}}],["double",{"2":{"10":1}}],["documentation",{"2":{"5":1,"25":1}}],["db22bv",{"2":{"7":1}}],["syntax",{"0":{"23":1},"2":{"23":1}}],["sd",{"0":{"20":1}}],["ssl=false",{"2":{"18":1}}],["survivor",{"2":{"18":1}}],["survivorratio=n",{"2":{"18":1}}],["survivor空间等名词",{"2":{"15":1}}],["survivor空间",{"2":{"15":1,"18":1}}],["sun",{"2":{"18":4}}],["shiki",{"2":{"23":1}}],["shenandoah",{"2":{"18":1}}],["short",{"2":{"10":1}}],["swt停顿时间",{"2":{"18":1}}],["sweep算法会导致内存碎片比较多",{"2":{"18":1}}],["sweep收集器运行示意图",{"2":{"18":1}}],["sweep收集器运行示意图如下",{"2":{"18":1}}],["sweep",{"2":{"18":2}}],["scavenge的特点是什么",{"2":{"18":1}}],["scavenge收集器",{"2":{"18":1}}],["scavenge",{"2":{"18":4}}],["script>",{"2":{"0":1}}],["script",{"2":{"0":1}}],["satb",{"2":{"18":1}}],["service",{"2":{"18":1}}],["server",{"2":{"18":2}}],["serial系列是单线程",{"2":{"18":1}}],["serial",{"2":{"18":5}}],["searching",{"2":{"18":2}}],["session",{"2":{"18":1}}],["setup>",{"2":{"0":1}}],["socket等连接",{"2":{"18":1}}],["some",{"2":{"0":1,"22":1}}],["stop",{"2":{"18":1}}],["stw",{"2":{"18":2}}],["stw就是在标记垃圾的时候",{"2":{"18":1}}],["string",{"2":{"15":1,"18":1}}],["state",{"2":{"18":1}}],["statement",{"2":{"18":1}}],["static",{"2":{"10":1}}],["stackoverflowerror",{"2":{"15":2}}],["stack",{"2":{"15":2}}],["site",{"2":{"0":1}}],["an",{"2":{"24":2}}],["and",{"2":{"0":2,"18":1}}],["additional",{"2":{"23":1}}],["async",{"2":{"18":1}}],["arthas阿里开源诊断工具",{"2":{"18":1}}],["area",{"2":{"15":1}}],["authenticate=false",{"2":{"18":1}}],["allocationbuffer",{"2":{"18":1}}],["a",{"2":{"10":1,"19":1,"24":8}}],["access",{"2":{"0":1}}],["apis",{"2":{"0":1,"5":1}}],["api",{"0":{"0":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1},"2":{"0":1}}],["tip",{"2":{"24":4}}],["tid=0x00007fbe2c164000",{"2":{"18":1}}],["text",{"2":{"18":2}}],["tda",{"2":{"18":1}}],["td5a84ty4vel22ge",{"2":{"7":1}}],["txt",{"2":{"18":1}}],["tlabwastetargetpercent",{"2":{"18":1}}],["tlab",{"2":{"18":4}}],["table",{"2":{"15":1,"18":1}}],["tulingzhouyu",{"2":{"7":1}}],["top",{"2":{"18":3}}],["to",{"2":{"0":1,"15":1,"19":1}}],["threadlocal的弱引用导致内存泄漏也是个老生常谈的话题了",{"2":{"18":1}}],["threadlocal使用不当",{"2":{"18":1}}],["thread",{"2":{"18":3}}],["theme",{"0":{"2":1},"2":{"0":4,"2":1}}],["the",{"2":{"0":3,"5":2,"18":6,"22":1,"25":2}}],["this",{"2":{"0":1,"22":1,"24":10}}],["block",{"2":{"24":2}}],["built",{"2":{"22":1}}],["b",{"2":{"19":1}}],["box",{"2":{"24":2}}],["boolean值为false等",{"2":{"16":1}}],["boolean",{"2":{"10":1}}],["both",{"2":{"0":1}}],["be",{"2":{"0":1}}],["byte",{"2":{"10":1}}],["by",{"2":{"0":1,"22":1,"23":1}}],["plain",{"2":{"18":2}}],["platform",{"2":{"14":1}}],["p",{"2":{"18":1}}],["pid",{"2":{"18":12}}],["permstat",{"2":{"18":1}}],["powered",{"2":{"23":1}}],["port",{"2":{"19":1}}],["port=1808",{"2":{"18":1}}],["pool",{"2":{"15":2}}],["parallelgcthreads=n",{"2":{"18":2}}],["parallel",{"2":{"18":9}}],["parnew",{"2":{"18":2}}],["page",{"0":{"3":1,"4":1},"2":{"0":7,"3":1,"22":1}}],["png",{"2":{"18":86}}],["p6wbr",{"2":{"7":1}}],["prio=0",{"2":{"18":1}}],["prio=9",{"2":{"18":1}}],["printf",{"2":{"18":3}}],["printcompilation",{"2":{"18":1}}],["provides",{"2":{"23":1}}],["provided",{"2":{"0":1,"22":1}}],["profilerjava",{"2":{"18":1}}],["program",{"2":{"15":1}}],["pre>",{"2":{"0":6}}]],"serializationVersion":2}';export{e as default};
